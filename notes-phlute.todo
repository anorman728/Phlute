Phlute:
* Kind of a side project that I think will be useful in a number of PHP projects.
* A project that takes XML and generates a PHP class file.
* Readme:
    @begin=plain@
        Phlute is a single-file PHP script that generates a set of PHP class files based on an XML template.
        
        It's basically just a run-of-the-mill code generator.  I found that I was typing in a lot of stuff repeatedly, so I thought it would be a whole lot easier if I just outline classes in XML and generate them.

        This helps map out larger projects, so I can think of them more conceptually instead of spending a lot of time typing code.

        It's just for initial creation.  Not for modifying existing files.

        THERE IS NO TEST.  Sorry.

        Why is it called "Phlute"?  Because I'm terrible at naming things.
    @end=plain@
* Okay, I'll need an outline now.
* I've got an idea of what I want the xml to look like.

* Okay, I'm at the point where I want to actually start building a file.
    * I was originally thinking about collecting everything into an object first, but now I'm thinking I'll just build the file while going through the nodes.

* I'm building the file, but I'm trying to think if there's a way to abstract some of this code.
    * Okay, yeah, I definitely am thinking that.
    * I think I want another class to take in the class node and filepath, as a constructor.  Then it builds the individual parts.

* I'm much closer, but I'm realizing something about the indentation in the docblocks.
    * I need to strip the whitespace, then break apart the statements into lines.
    * I'm wondering if I handled something like this in saute.
        * I did not.  All docblocks were completely hardcoded.
    * So, I need a function that:
        * Takes in a string.
        * Strips whitespace from that string
        * Replaces all \n\s+ with a space, but preserves empty lines.
        * Loop until no string left to process
            * Adds the appropriate indentation whitespace.
            * Adds ` * `
            * Finds the first whitespace to the left of the 80-char mark.
            * Removes substring(0,<whitespacepos>) and adds it to an array.
* I think I'm going to have to abstract a little more than I originally thought.  This is becoming extraordinarily complicated.
    * Three more classes-- PropertyBuilder, FunctionBuilder, DocblockBuilder.
    * Then some functions common to all of them.
    + FileWriter
        * This one's new.  These different classes definitely need to be able to actually manage appending to the file.
        + Update ClassBuilder to create FileWriter object.
        + Update ClassBuilder to use FileWriter object to write to file.
    + DocblockBuilder
        * This is going to need to have the FileWriter object passed to it.
        @begin=php@<?
            // The way I want it to work:

            $docBuilder = new DocblockBuilder($this->getFileWriter(), 0); // 0 is indent.

            // Description.
            $desc = getImmediateChildrenByName($this->getClassNode(), 'doc')[0]->nodeValue;
            $docBuilder->setDesc($desc);

            // Author, if applicable.
            $author = $this->getClassNode()->getAttribute('author');
            if ($author) {
                $docBuilder->addAttribute('author', [$author]);
            }

            try {
                $docBuilder->write();
            } catch (\Throwable $t) {
                print_r("Found error in " . $this->pullClassName() . ': ' . $t->getMessage());
                die();
            }
        ?>@end=php@
        * How many columns are there for the attributes?
            * There's the one like @param.  That's the type.
            * Then there's the second one that's the data type for @param, but can be other things.
            * Then there's the third one that's the name of the variable.
            * Then there's the fourth one that's the description.  This one's going to go on the next line.
    + PropertyBuilder
    + MethodBuilder
        * This can't really just take in a method element, because it needs to be more versatile than that.
            * There won't be method elements for getters and setters.
        * That said, I'm really cutting myself off at the knees in terms of versatility if I don't.
            * If/when I make changes later, it will be *much* better to be able to only make those changes in the FunctionBuilder class.
        * Okay, I genuinely at this point think that the best thing to do here would be to actually dynamically build a function element to pass to make getters and setters.
        + Write function.
            * All done except for content.
                * If no content defined, add 'todo' comment.  Else add content.
            * Content is actually going to be a pain, because I need to make sure that the spacing is right.
                * I was going to say break apart the lines into arrays, but one huge problem is the first line.
                * I think the only way I can do this correctly is to treat the first line specially.
            * Here's what I want to do:
                * Break data into array by line break.
                * Remove ^\<\? from first line.
                * Remove \?\>$ from last line.
                * Find the smallest amount of space at the beginning of each line, *excluding* the first line, because that's going to be very short.
                * Trim every line (except the first) by that amount.
                * Remove first and last line iff they are empty strings.
                * Insert each line, with appropriate indent level.
            * The above will mean that source XML files cannot mix tabs and space.
                * The more I think about it, this whole thing pretty much assumes only spaces in both XML and resulting PHP.
                * Well, I guess that's fine.
        + Abstract CData to separate class.
        + Add option for private or protected function.
    + Return to PropertyBuilder
        * The PropertyBuilder class itself needs to be what creates the getters and setters.  It'll just be easiest that way.
        * So, it'll need to instantiate FunctionBuilder.
+ Fix no private functions.
    * Not sure what I missed, but private functions are not being written as private.
    * Because I added the function and never actually set anything.
+ If writing line of just spaces to file, make it just an empty line.
    * Right now, I'm indenting some empty lines inside functions.
+ Traits
+ Remove extra space before closing of class.
    * I think I want to do this by not adding the line in the first place.
    * And I think the way to do that is to not add the blank line at the end of a function.
    * Which means that I want to add the blank line at the beginning of a function.
    * Which means that I want to not add one of the blank lines that I'm adding before all the functions.
    * But, wait-- I'm not writing a blank line after every function.
        * Oh, yes, I am.
+ Figure out how to get the content elements to be syntax-highlighted for PHP in Vim.
    * I'm kind of wondering if this is a problem that's already been resolved.  Maybe not putting PHP in CDATA is common, but the very nature of CDATA suggests that maybe Vim would want to add this feature.
    * https://stackoverflow.com/questions/2713353/how-to-syntax-highlight-xml-in-cdata-elements-in-vim
        * Okay, this is wrong.
    * To find out where syntax files are:
        * `echo $VIMRUNTIME`
    * Okay, I did this by making a modified XML syntax highlighter file and setting a modeline.

Things I want to come back to:
* Basically stuff that I want to do, but not yet because I'll get overwhelmed.
+ tests
    + FileWriter
    + DocblockBuilder
    + CDataHandler
    + MethodBuilder
    + PropertyBuilder
+ Move tests to subfolder.
    * I think I should be able to do this by only editing test-setup.php.
- Preprocess the xml, line by line, to allow php tags.
    * In the example, create <php>...</php> tags.
    * *Before* it's loaded into DOMDocument, take out those lines, replace with an element like <php ref="arraynumber"/>.  This is the preprocessing.
    * When actually building the file, find those lines when come to that reference.
    ! I'm glad I didn't do this right away, because I'm seriously starting to think about the possible ramifications of this.
        * It could potentially be *extremely* irritating with text editors, and things like pygmentize.
        * The two primary advantages are being able to have ]]> in PHP (which almost never happens) and typing less for PHP blocks, which isn't really that big a deal.
    --I think that for the time being, I want to ignore this.
+ Search the input text for too many `]]>`.
    * Give warning (probably exception) if find more instances of `]]>` than `<![CDATA[`.
    * Or maybe some regex?  Basically cannot have any instance of two closing after one opening, and if that's found I'm going to assume it's because ]]> is accidentally put in PHP.
        * This would probably be better, but it would be much easier to just count them.
+ Things that need to be optional
    * Meaning they won't cause exception to be thrown.
    + Uses
    + Traits
    + Properties
    + Methods
+ buildDirectory needs to check `output` attribute before using the default value.
+ If directory does not exist, create it.
- Corresponding test files
    * I think I want it to simply create one test file for each public method and mark test as incomplete.
    * Trying to think of the best way to do this.
        * Creating a whole new ClassBuilder instance would be a mistake, of course.
        ? But would it be a good idea to do this at all?
            * I feel like it's enormously prone to error, and might actually be better to just design the test files as part of the overall design.
            * Plus it would be an enormous pain.
    --For the time being, at least, I'm canceling this.
+ Extra docblock
    * For the phpunit note.
+ Remove extra line from superdoc.
    * This is basically just going to mean not adding the extra line if there are no attributes.
+ Macros
    * I'm thinking this will be like preprocessor macros in C/C++.
        * Except hopefully not verboten to use.
    * Right now I'm thinking that the FileWriter may be what handles this?
        * Or maybe a new class that's handled by the FileWriter.
    * Probably basically just something that does a search and replace for each line being dumped into the file.
    * I dunno, though.  The more I think about macros for the substitutions, the more it just doesn't really work that well.
    * Well, now I think I have a better idea.  Basically, combine them into one.
        * The macro def would have arguments, like $1, $2, etc.
        * Calling the macro would be like {{mymac arg1 arg2}}.
        * And there would be no need for arguments at all.
        * This would allow both constants and substitutions in one.
        @begin=xml@
            <macros>
                <def name="mymac">This is a macro.  This is $1, the first argument, and this is $2, the second argument.</def>
            </macros>
            <!-- Later in the code... -->
            <method>
                <doc>{{mymac function docblock}}</doc> <!-- The docblock of the function is "This is a macro.  This is function, the first argument, and this is docblock, the second argument." -->
            </method>
        @end=xml@
    * This can't be done in the FileWriter, though, now that I think of it.
        * I'm not sure where it needs to go, but it can't be in the FileWriter.  The file writer doesn't, and shouldn't, manage line breaks.  And macros can and should be able to have enough information that require a line break.
        * But I also want it to be able to be used for function names and the like.
        * Maybe it should *only* be accessible in docblocks?
            * That makes sense to me, but there are a couple of issues here--
                * Would require a lot of new parameters being passed (not that big a deal, but a mild irritation).
                * The naming would be terrible.
            * Overall, I don't think I like this idea.
        ! Oh, no-- I need a new function to get a node's content.
            * This is what makes most sense to me.  It does mean that it would only apply to content in a node, and not attributes, though.
                * Which, ironically, means, just docblocks.  But it's what by far makes the most sense to me, from *both* a coding perspective and from an end-user perspective.
                * And it wouldn't be *too* difficult to expand this to attributes if I wanted to.
    - Constants
        * Need to be able to define a constant somewhere and use them in multiple files.
    - Substitutions
        * Like, need to be able to put "This class {{classname}} has a unit test in {{location}}", and set that as a constant, and substitute regularly.
    * So, do as defined above.  They're both going to be the same.
    * Okay, but there's another problem now-- Getting that information.
        * The easiest way would be static variables/functions in a class.  That way I wouldn't need to pass it along.
        * That may not be good for my reputation, but I really do think this is the cleanest way to do this.
    + Add the macro node to the sample.
    + Design MacroProcessor class.
        ! Will definitely want a test script for this.
        + Static variable for the macros.  An array with key as name and value as the string.
        + Static function for building the aforementioned array from the macros node.
        + Static function for processing a string.
            * Is going to include arguments.
            + Find all instances of {{.*?}}.
            + If no {{.*?}} found, return input.
            + Foreach found instance as {{instance}}:
                + If spaces found
                    + Replace $1...$n with arguments in macro string.
                + Replace {{instance}} with macro.
            + Fix problem I just realized.
                ! The arguments cannot have spaces.
                * The way this works as a whole is problematic, I think.  It can't explode by space.
                * I absolutely need to have arguments in quotes.
                * For the sake of ease of code and clarity of the xml source, it would probably be best to make them *always* required to have quotes.
                    * It's actually just about as easy to allow not having quotes.
                ! I need a "next" function.
                    * Kinda like pop.
            - Allow literal double quote in argument.
                * I'm not 100% sure yet how to do this.
                * But it will almost certainly involve the `next` method.
                * I guess I'll just need to check if prior character is a backslash, and if so, then go to the next one.
                * The only solution I can think of is to make a new strpos function.
                * If I allow literal quotes with blackslashes, I'm going to have to replace them.  That also means I'm going to have to handle literal backslashes, too.
                * The logic of this is going to be difficult.
                ! I actually think I'm going to go ahead and put this off.
            - Allow literal dollar sign followed by number in macro.
                * I decided against it before, but I'm realizing that I'll need to.
                    * I may decide to make a joke about the dollar menu at McDonald's.
            --These were put off.
    + Call the first function mentioned before in the Main class.
        * By "first function", I'm pretty sure I meant the function to parse the macros, i.e., MacroProcessor::parseMacros.
        ! I just noticed an inconsistency in the way the xml is designed.
            * Everything else have things grouped together, like every `macro` element is a child of the `macros` element.
            * But that's not the case for classes.  Every `class` elment is a child of the root element.
            * For the time being... I think I'm just going to ignore this inconsistency.
    + Create independent function for getting Node text data.
        * It's going to pull from the node, then run it through the processor in MacroProcessor.
    + Use aforementioned function anywhere we pull node text.
        * Maybe exception for CData.  I'm not sure yet.  Depends on how hard it will be.
        * I actually just realized-- If there's a problem with CData, at least the way that I think there *might* be, then there's going to be a problem with docs that have multiple lines.
            ! I'm going to manually check all docs that have multiple lines, to double-check that they're working as I intend.
        * Will need to replace almost any instanceof getting `nodeValue`.
            * Did the docblock one (which might be the only one, actually).
            * There's two places for docblock, actually-- The classes and the methods.  I have them both now.
- Allow literal $ in macros.
    --Nah, forget that.  It would only impact $\d, and I never use that pattern.
+ Make sure it works if no macros are defined at all.
    * Couple of things that needed to be fixed.
    + Don't call parseMacros if there are no macros to be parsed.
    + Throw exception if macro not found.
+ 'extends' attribute.
+ abstract classes
+ abstract functions
    ! I want to put this in the manual test.
    + Create isAbstract function.
    + If abstract, then
        + Start declaration with 'abstract '.
        + End declaration with semicolon.
        + Skip rest of writeFunction after writing signature.
* Considering rethinking abstract, static, and visibility.
    * No, nevermind.  That would actually be more difficult.
    * I was thinking that they would all be handled by a "prefix" attribute, which would default to "public".  But that would mean getting rid of the public/protected/private groupings, and I actually really like those.
    * Plus I would still need special treatment of abstract functions, since those have no content.
    * That said, I could still have some kind of minor change to the way it's passed that I think I would like.
    * Like, instead of `abstract="1" static="1"` I could have `characteristics="abstract static"`.
    * But not that attribute name.  I'd need a better name.
        * The best I can think of atm is "keywords".
    * I do actually like this idea quite a bit.
    + `keywords` update.
        * Only for the ones that I already have.
        + abstract classes.
            + Add `keywords` property.
                * An array, with appropriate getter and setter.
            + On construction, get `keywords` attribute, exploded by space.
            + abstractDeclarationIfApplicable is going to return abstract if it's found in the `keywords` array.
        + abstract functions.
            * Going to involve changes to MethodBuilder, but best not to add anything to constructor.
                * Because MethodBuilder is a child class of ElementBuilder, and I don't want to override the constructor.  Then every time I make a change to the constructor, I'd have to make a change to the child class.
            * I think I'll just make the changes to write.
            * This one will involve test-methodbuilder.
            ! Wait a minute--
                * I think maybe this actually should go into the the parent class, ElementBuilder.
                * Because although *abstract* would not apply, *static* would, and this is going to work out the same way.
            + Make keywords property.
                * Including getter and setter.
            - Set keywords array at beginning of write function.
            + Set keywords array in constructor.
            + isAbstract now needs to check if the word 'abstract' is in the array.
+ static functions
    * Added isStatic method to parent class, so now need to actually put it into practice with functions.
+ static properties
    ! Don't forget to add static attribute to getter and setter.
+ Constants
    * Probably just make them child elements of the properties element, and just make them an options of the Property object.
    * No, not quite-- Make the tag name `constant`.
    * Might be another child class to ElementBuilder.
    + Make ConstantBuilder class.
    + Implement ConstantBuilder.
        * Alongside wherever PropertyBuilder is used.
+ Decent documentation.
    * I'm getting to the point where I at least need some kind of reference material.
> Const type update
    * Right now, constant strings are 100% broken.  They're always set as if they were ints.
    * But they are working correctly for properties.  It's just that with constants I forgot that there are things other than ints.
    * Trying to find a way to do this without code duplication.
        * The PropertyBuilder class already has a buildDefaultValueString which does exactly what I want it to do.
        * I don't want to copy-paste it.
        * It wouldn't make sense to put it in the parent class because it's not usable for MethodBuilder.
        * I really hate to make a trait just for this, but I think it's between putting it in the parent class and putting it in a trait.
        * I guess trait it is.
        * No-- I really think it would be better to make it a protected method in the parent class.
- Different return values for docblock in functions.
    * I don't remember what I meant by this-- Maybe multiple possiblities with |, or maybe variant.  But I'll figure it out when I get to this point.
    --Specified in more detail below.
> Variant type for properties.
> Variant return types for methods.
> Variant input types.
> interfaces
    * i.e., implements
> If information is small enough, docblock needs to go on one line.
> Public properties
> 'throws" attribute for functions.
> Signature needs to be multiline if too long.
> Pass by reference.
> Custom setters and getters.
    * Since the whole point of setters and getters is to make them more versatile for doing other things.
> Property doc attribute needs to optionally be a doc child element.
> nullable properties
    * Basically just means type attribute will start with '?' in input and replaced by <type>|null in docblock.
> Variant return types.
    * If return type of property is variant or contains a '|', then don't enforce a type.
> Namespaced docblock types.
    * If input or return type matches one of the 'use' statements, handle accordingly.
    * i.e., in docblocks it needs to be fully-qualified, but in signatures it shouldn't be.
- Added comment for // todo and markasincomplete.
    * Because I want to put //dmz1 in there.
    --For the time being, I'm not doing automatic test files.
> Filter
    * I want to be able to pass a filter that matches class names, so only class names are built that match that pattern.
> Delete files
    * Need an option to pass from CLI to delete all files that would otherwise be written.
> No space before functions.
    * I did this as an easy way to prevent space at end of last function, but it's actually causing other problems.
    * If there are no use statements or variables or what-have-you, if the first thing in a class is a function, then there's an unwanted space.
    * I'm going to have to figure out another way to fix that last space.

! This is the point where I would call this project probably effectively done for 1.0.
    * Though at this point I'm not actually versioning.

> Return to macroprocessor.
    * These were put off earlier.
    * Note: I don't know if this will work yet, but an idea that I have is to replace all instances of `\$` with something like [[litdol]] at first, then replace that with a literal dollar sign later.
    > Allow literal double quote in argument.
    > Allow literal dollar sign followed by number in macro.
    > Allow literal {{ in source.
> Allow value as child CDATA element for constants.
    * Mostly to let me define big arrays as constants.
> Doc for property *and* constants need to be allowed to be child elements so they can be longer.
