Phlute:
* Kind of a side project that I think will be useful in a number of PHP projects.
* A project that takes XML and generates a PHP class file.
* Readme:
    @begin=plain@
        Phlute is a single-file PHP script that generates a set of PHP class files based on an XML template.
        
        It's basically just a run-of-the-mill code generator.  I found that I was typing in a lot of stuff repeatedly, so I thought it would be a whole lot easier if I just outline classes in XML and generate them.

        This helps map out larger projects, so I can think of them more conceptually instead of spending a lot of time typing code.

        It's just for initial creation.  Not for modifying existing files.

        THERE IS NO TEST.  Sorry.

        Why is it called "Phlute"?  Because I'm terrible at naming things.
    @end=plain@
* Okay, I'll need an outline now.
* I've got an idea of what I want the xml to look like.

* Okay, I'm at the point where I want to actually start building a file.
    * I was originally thinking about collecting everything into an object first, but now I'm thinking I'll just build the file while going through the nodes.

* I'm building the file, but I'm trying to think if there's a way to abstract some of this code.
    * Okay, yeah, I definitely am thinking that.
    * I think I want another class to take in the class node and filepath, as a constructor.  Then it builds the individual parts.

* I'm much closer, but I'm realizing something about the indentation in the docblocks.
    * I need to strip the whitespace, then break apart the statements into lines.
    * I'm wondering if I handled something like this in saute.
        * I did not.  All docblocks were completely hardcoded.
    * So, I need a function that:
        * Takes in a string.
        * Strips whitespace from that string
        * Replaces all \n\s+ with a space, but preserves empty lines.
        * Loop until no string left to process
            * Adds the appropriate indentation whitespace.
            * Adds ` * `
            * Finds the first whitespace to the left of the 80-char mark.
            * Removes substring(0,<whitespacepos>) and adds it to an array.
* I think I'm going to have to abstract a little more than I originally thought.  This is becoming extraordinarily complicated.
    * Three more classes-- PropertyBuilder, FunctionBuilder, DocblockBuilder.
    * Then some functions common to all of them.
    + FileWriter
        * This one's new.  These different classes definitely need to be able to actually manage appending to the file.
        + Update ClassBuilder to create FileWriter object.
        + Update ClassBuilder to use FileWriter object to write to file.
    + DocblockBuilder
        * This is going to need to have the FileWriter object passed to it.
        @begin=php@<?
            // The way I want it to work:

            $docBuilder = new DocblockBuilder($this->getFileWriter(), 0); // 0 is indent.

            // Description.
            $desc = getImmediateChildrenByName($this->getClassNode(), 'doc')[0]->nodeValue;
            $docBuilder->setDesc($desc);

            // Author, if applicable.
            $author = $this->getClassNode()->getAttribute('author');
            if ($author) {
                $docBuilder->addAttribute('author', [$author]);
            }

            try {
                $docBuilder->write();
            } catch (\Throwable $t) {
                print_r("Found error in " . $this->pullClassName() . ': ' . $t->getMessage());
                die();
            }
        ?>@end=php@
        * How many columns are there for the attributes?
            * There's the one like @param.  That's the type.
            * Then there's the second one that's the data type for @param, but can be other things.
            * Then there's the third one that's the name of the variable.
            * Then there's the fourth one that's the description.  This one's going to go on the next line.
    + PropertyBuilder
    + MethodBuilder
        * This can't really just take in a method element, because it needs to be more versatile than that.
            * There won't be method elements for getters and setters.
        * That said, I'm really cutting myself off at the knees in terms of versatility if I don't.
            * If/when I make changes later, it will be *much* better to be able to only make those changes in the FunctionBuilder class.
        * Okay, I genuinely at this point think that the best thing to do here would be to actually dynamically build a function element to pass to make getters and setters.
        + Write function.
            * All done except for content.
                * If no content defined, add 'todo' comment.  Else add content.
            * Content is actually going to be a pain, because I need to make sure that the spacing is right.
                * I was going to say break apart the lines into arrays, but one huge problem is the first line.
                * I think the only way I can do this correctly is to treat the first line specially.
            * Here's what I want to do:
                * Break data into array by line break.
                * Remove ^\<\? from first line.
                * Remove \?\>$ from last line.
                * Find the smallest amount of space at the beginning of each line, *excluding* the first line, because that's going to be very short.
                * Trim every line (except the first) by that amount.
                * Remove first and last line iff they are empty strings.
                * Insert each line, with appropriate indent level.
            * The above will mean that source XML files cannot mix tabs and space.
                * The more I think about it, this whole thing pretty much assumes only spaces in both XML and resulting PHP.
                * Well, I guess that's fine.
        + Abstract CData to separate class.
        + Add option for private or protected function.
    + Return to PropertyBuilder
        * The PropertyBuilder class itself needs to be what creates the getters and setters.  It'll just be easiest that way.
        * So, it'll need to instantiate FunctionBuilder.
+ Fix no private functions.
    * Not sure what I missed, but private functions are not being written as private.
    * Because I added the function and never actually set anything.
+ If writing line of just spaces to file, make it just an empty line.
    * Right now, I'm indenting some empty lines inside functions.
+ Traits
+ Remove extra space before closing of class.
    * I think I want to do this by not adding the line in the first place.
    * And I think the way to do that is to not add the blank line at the end of a function.
    * Which means that I want to add the blank line at the beginning of a function.
    * Which means that I want to not add one of the blank lines that I'm adding before all the functions.
    * But, wait-- I'm not writing a blank line after every function.
        * Oh, yes, I am.
+ Figure out how to get the content elements to be syntax-highlighted for PHP in Vim.
    * I'm kind of wondering if this is a problem that's already been resolved.  Maybe not putting PHP in CDATA is common, but the very nature of CDATA suggests that maybe Vim would want to add this feature.
    * https://stackoverflow.com/questions/2713353/how-to-syntax-highlight-xml-in-cdata-elements-in-vim
        * Okay, this is wrong.
    * To find out where syntax files are:
        * `echo $VIMRUNTIME`
    * Okay, I did this by making a modified XML syntax highlighter file and setting a modeline.

Things I want to come back to:
* Basically stuff that I want to do, but not yet because I'll get overwhelmed.
+ tests
    + FileWriter
    + DocblockBuilder
    + CDataHandler
    + MethodBuilder
    + PropertyBuilder
+ Move tests to subfolder.
    * I think I should be able to do this by only editing test-setup.php.
- Preprocess the xml, line by line, to allow php tags.
    * In the example, create <php>...</php> tags.
    * *Before* it's loaded into DOMDocument, take out those lines, replace with an element like <php ref="arraynumber"/>.  This is the preprocessing.
    * When actually building the file, find those lines when come to that reference.
    ! I'm glad I didn't do this right away, because I'm seriously starting to think about the possible ramifications of this.
        * It could potentially be *extremely* irritating with text editors, and things like pygmentize.
        * The two primary advantages are being able to have ]]> in PHP (which almost never happens) and typing less for PHP blocks, which isn't really that big a deal.
    --I think that for the time being, I want to ignore this.
+ Search the input text for too many `]]>`.
    * Give warning (probably exception) if find more instances of `]]>` than `<![CDATA[`.
    * Or maybe some regex?  Basically cannot have any instance of two closing after one opening, and if that's found I'm going to assume it's because ]]> is accidentally put in PHP.
        * This would probably be better, but it would be much easier to just count them.
+ Things that need to be optional
    * Meaning they won't cause exception to be thrown.
    + Uses
    + Traits
    + Properties
    + Methods
+ buildDirectory needs to check `output` attribute before using the default value.
+ If directory does not exist, create it.
- Corresponding test files
    * I think I want it to simply create one test file for each public method and mark test as incomplete.
    * Trying to think of the best way to do this.
        * Creating a whole new ClassBuilder instance would be a mistake, of course.
        ? But would it be a good idea to do this at all?
            * I feel like it's enormously prone to error, and might actually be better to just design the test files as part of the overall design.
            * Plus it would be an enormous pain.
    --For the time being, at least, I'm canceling this.
+ Extra docblock
    * For the phpunit note.
+ Remove extra line from superdoc.
    * This is basically just going to mean not adding the extra line if there are no attributes.
+ Macros
    * I'm thinking this will be like preprocessor macros in C/C++.
        * Except hopefully not verboten to use.
    * Right now I'm thinking that the FileWriter may be what handles this?
        * Or maybe a new class that's handled by the FileWriter.
    * Probably basically just something that does a search and replace for each line being dumped into the file.
    * I dunno, though.  The more I think about macros for the substitutions, the more it just doesn't really work that well.
    * Well, now I think I have a better idea.  Basically, combine them into one.
        * The macro def would have arguments, like $1, $2, etc.
        * Calling the macro would be like {{mymac arg1 arg2}}.
        * And there would be no need for arguments at all.
        * This would allow both constants and substitutions in one.
        @begin=xml@
            <macros>
                <def name="mymac">This is a macro.  This is $1, the first argument, and this is $2, the second argument.</def>
            </macros>
            <!-- Later in the code... -->
            <method>
                <doc>{{mymac function docblock}}</doc> <!-- The docblock of the function is "This is a macro.  This is function, the first argument, and this is docblock, the second argument." -->
            </method>
        @end=xml@
    * This can't be done in the FileWriter, though, now that I think of it.
        * I'm not sure where it needs to go, but it can't be in the FileWriter.  The file writer doesn't, and shouldn't, manage line breaks.  And macros can and should be able to have enough information that require a line break.
        * But I also want it to be able to be used for function names and the like.
        * Maybe it should *only* be accessible in docblocks?
            * That makes sense to me, but there are a couple of issues here--
                * Would require a lot of new parameters being passed (not that big a deal, but a mild irritation).
                * The naming would be terrible.
            * Overall, I don't think I like this idea.
        ! Oh, no-- I need a new function to get a node's content.
            * This is what makes most sense to me.  It does mean that it would only apply to content in a node, and not attributes, though.
                * Which, ironically, means, just docblocks.  But it's what by far makes the most sense to me, from *both* a coding perspective and from an end-user perspective.
                * And it wouldn't be *too* difficult to expand this to attributes if I wanted to.
    - Constants
        * Need to be able to define a constant somewhere and use them in multiple files.
    - Substitutions
        * Like, need to be able to put "This class {{classname}} has a unit test in {{location}}", and set that as a constant, and substitute regularly.
    * So, do as defined above.  They're both going to be the same.
    * Okay, but there's another problem now-- Getting that information.
        * The easiest way would be static variables/functions in a class.  That way I wouldn't need to pass it along.
        * That may not be good for my reputation, but I really do think this is the cleanest way to do this.
    + Add the macro node to the sample.
    + Design MacroProcessor class.
        ! Will definitely want a test script for this.
        + Static variable for the macros.  An array with key as name and value as the string.
        + Static function for building the aforementioned array from the macros node.
        + Static function for processing a string.
            * Is going to include arguments.
            + Find all instances of {{.*?}}.
            + If no {{.*?}} found, return input.
            + Foreach found instance as {{instance}}:
                + If spaces found
                    + Replace $1...$n with arguments in macro string.
                + Replace {{instance}} with macro.
            + Fix problem I just realized.
                ! The arguments cannot have spaces.
                * The way this works as a whole is problematic, I think.  It can't explode by space.
                * I absolutely need to have arguments in quotes.
                * For the sake of ease of code and clarity of the xml source, it would probably be best to make them *always* required to have quotes.
                    * It's actually just about as easy to allow not having quotes.
                ! I need a "next" function.
                    * Kinda like pop.
            - Allow literal double quote in argument.
                * I'm not 100% sure yet how to do this.
                * But it will almost certainly involve the `next` method.
                * I guess I'll just need to check if prior character is a backslash, and if so, then go to the next one.
                * The only solution I can think of is to make a new strpos function.
                * If I allow literal quotes with blackslashes, I'm going to have to replace them.  That also means I'm going to have to handle literal backslashes, too.
                * The logic of this is going to be difficult.
                ! I actually think I'm going to go ahead and put this off.
            - Allow literal dollar sign followed by number in macro.
                * I decided against it before, but I'm realizing that I'll need to.
                    * I may decide to make a joke about the dollar menu at McDonald's.
            --These were put off.
    + Call the first function mentioned before in the Main class.
        * By "first function", I'm pretty sure I meant the function to parse the macros, i.e., MacroProcessor::parseMacros.
        ! I just noticed an inconsistency in the way the xml is designed.
            * Everything else have things grouped together, like every `macro` element is a child of the `macros` element.
            * But that's not the case for classes.  Every `class` elment is a child of the root element.
            * For the time being... I think I'm just going to ignore this inconsistency.
    + Create independent function for getting Node text data.
        * It's going to pull from the node, then run it through the processor in MacroProcessor.
    + Use aforementioned function anywhere we pull node text.
        * Maybe exception for CData.  I'm not sure yet.  Depends on how hard it will be.
        * I actually just realized-- If there's a problem with CData, at least the way that I think there *might* be, then there's going to be a problem with docs that have multiple lines.
            ! I'm going to manually check all docs that have multiple lines, to double-check that they're working as I intend.
        * Will need to replace almost any instanceof getting `nodeValue`.
            * Did the docblock one (which might be the only one, actually).
            * There's two places for docblock, actually-- The classes and the methods.  I have them both now.
- Allow literal $ in macros.
    --Nah, forget that.  It would only impact $\d, and I never use that pattern.
+ Make sure it works if no macros are defined at all.
    * Couple of things that needed to be fixed.
    + Don't call parseMacros if there are no macros to be parsed.
    + Throw exception if macro not found.
+ 'extends' attribute.
+ abstract classes
+ abstract functions
    ! I want to put this in the manual test.
    + Create isAbstract function.
    + If abstract, then
        + Start declaration with 'abstract '.
        + End declaration with semicolon.
        + Skip rest of writeFunction after writing signature.
* Considering rethinking abstract, static, and visibility.
    * No, nevermind.  That would actually be more difficult.
    * I was thinking that they would all be handled by a "prefix" attribute, which would default to "public".  But that would mean getting rid of the public/protected/private groupings, and I actually really like those.
    * Plus I would still need special treatment of abstract functions, since those have no content.
    * That said, I could still have some kind of minor change to the way it's passed that I think I would like.
    * Like, instead of `abstract="1" static="1"` I could have `characteristics="abstract static"`.
    * But not that attribute name.  I'd need a better name.
        * The best I can think of atm is "keywords".
    * I do actually like this idea quite a bit.
    + `keywords` update.
        * Only for the ones that I already have.
        + abstract classes.
            + Add `keywords` property.
                * An array, with appropriate getter and setter.
            + On construction, get `keywords` attribute, exploded by space.
            + abstractDeclarationIfApplicable is going to return abstract if it's found in the `keywords` array.
        + abstract functions.
            * Going to involve changes to MethodBuilder, but best not to add anything to constructor.
                * Because MethodBuilder is a child class of ElementBuilder, and I don't want to override the constructor.  Then every time I make a change to the constructor, I'd have to make a change to the child class.
            * I think I'll just make the changes to write.
            * This one will involve test-methodbuilder.
            ! Wait a minute--
                * I think maybe this actually should go into the the parent class, ElementBuilder.
                * Because although *abstract* would not apply, *static* would, and this is going to work out the same way.
            + Make keywords property.
                * Including getter and setter.
            - Set keywords array at beginning of write function.
            + Set keywords array in constructor.
            + isAbstract now needs to check if the word 'abstract' is in the array.
+ static functions
    * Added isStatic method to parent class, so now need to actually put it into practice with functions.
+ static properties
    ! Don't forget to add static attribute to getter and setter.
+ Constants
    * Probably just make them child elements of the properties element, and just make them an options of the Property object.
    * No, not quite-- Make the tag name `constant`.
    * Might be another child class to ElementBuilder.
    + Make ConstantBuilder class.
    + Implement ConstantBuilder.
        * Alongside wherever PropertyBuilder is used.
+ Decent documentation.
    * I'm getting to the point where I at least need some kind of reference material.
+ Const type update
    * Right now, constant strings are 100% broken.  They're always set as if they were ints.
    * But they are working correctly for properties.  It's just that with constants I forgot that there are things other than ints.
    * Trying to find a way to do this without code duplication.
        * The PropertyBuilder class already has a buildDefaultValueString which does exactly what I want it to do.
        * I don't want to copy-paste it.
        * It wouldn't make sense to put it in the parent class because it's not usable for MethodBuilder.
        * I really hate to make a trait just for this, but I think it's between putting it in the parent class and putting it in a trait.
        * I guess trait it is.
        * No-- I really think it would be better to make it a protected method in the parent class.
- Different return values for docblock in functions.
    * I don't remember what I meant by this-- Maybe multiple possiblities with |, or maybe variant.  But I'll figure it out when I get to this point.
    --Specified in more detail below.
+ Variant return types for method return.
    * Almost done even as it is.  If return type is missing from element, it works correctly in the declaration-- It's just the docblock that's wrong.
    * I actually think that I should only change the docblock behavior here.  If it's blank, then print variant.
    * Note that void already works as I need it to.
+ Other method return changes.
    * While I'm here, I think it would make sense to do this.
    + Nullable return types.
        * If type starts with `?`, then want to remove that from the docblock and append with a `|null`.
    + Multiple return types.
        * If type includes `|`, then cannot enforce a type.
    - Class return types need fully-qualified namespace in docblock.
        * Crap.
            * I don't have the `use` elements collected when building a method, and I don't *want* to do that, but there's not much of a choice here.
            * I'm going to have to collect these into an array before instantiating *any* MethodBuilder objects, and set this as a required object for every MethodBuilder object.
        * This is only going to be for docblocks, not the return type.
        + MethodBuilder
            + Make a property for this array that's *null* (not empty array) by default.
            + Make a setter for the use statements array in MethodBuilder.
                * <Class name> => <Fully-qualified class name>
                * Will want to use the test for this.
            + When write method, if array is null (not empty), throw exception.
                * This must always be set.
                ! I'll put this exception in the getter, but with a specific message.
            + When write method, docblock attributes need to take this into account.
                + Input
                + Returnval
        > Abstract the logic for getDocTypeFromInputNode.
            * I kinda hate to say it, but I'm starting to think this needs to be static properties and functions like MacroProcessor.
            * I hate doing those.  I feel like there's too many ways that can go wrong.
            * That's also going to require completely rethinking how this would work.
                * There would be significantly less code.
            * I think I have a better idea, actually.
                * Static wouldn't fit very well because unlike macros, it's not "universal".  It would change when I move to the next class.
                    * I feel like that would make its behavior precarious.
                * I think I really want to avoid that altogether.
            * Instead of building an array, make a class.
                * Then the object itself can handle getting the fully-qualified namespace and formatting it correctly.
                * This is actually a pretty obvious solution.  I feel kinda dumb not having thought of it before.
        > PropertyBuilder
            > When writing docblocks, need to use this.
            > When writing getters and setters, need to pass this to method builder.
        * Note that I'm fairly confident that I won't need this for ConstantBuilder.  I've never used anything other than primitive types or arrays for constants.
        > ClassBuilder
            > Make a private property that's an empty array for the use statements.
            > Collect the use statements in the appropriate format before building any methods (including getters and setters).
            > Pass the use statements to each MethodBuilder
            > Pass the use statements to each PropertyBuilder.
        --Better version below.
    + Class return types need fully-qualified namespace in docblock. (New version).
        + Create class to handle getting the fully-qualified namespace.
            * "UsedNamespaces"
            + Array holding the map of class name to fully-qualified class name.
            + Constructor that parses `uses` element.
            + Public function to handle getting the name.
                @begin=php@<?
                    // $className is passed.
                    $namespaceArr = $this->getNamespaceArr();
                    if (array_key_exists($className, $namespaceArr)) {
                        return $namespaceArr[$className];
                    }

                    return $className;
                ?>@end=php@
                * I just thought of a problem: I will need backslashes before output of fullyQualifiedName for class names even if there's no match, but not for primitive types.
                    ! So, if there's no match, I think I want to use is_object to determine whether or not to add a backslash.
                        ! No, that's not right-- The $type that I'm going to be getting is always going to be a string.
                    * I'm actually thinking now that the only thing I need to do is check if the class exists.
                        ! No, I feel stupid-- In that context, the class won't exist.
                    * The only thing I can think of so far is making an array of things that don't need the backslash.
                        * I don't like that because it's not very versatile, but now that I think of it, the context doesn't really allow for anything else.
                * I'm starting to wonder, though-- Should I need to add backslashes?  I think I might be wrong about this.
                    * Okay, yes I will.  Remember that this is for the docblocks and nothing else.  I'll need a starting backslash in all cases except primitive types.
            - NamespaceArr needs to be set to null be default.
            - getNamespaceArr needs to throw exception (clearly) if namespaceArr is null.
                * If there are no `use` statements, then an empty array will work.
            --Canceled points are no longer necessary.
        + Build UsedNamespaces instance in ClassBuilder.
            * Not Main.
            ! I need to handle the possibility of no use element.
                * I guess an empty one is technically already handled, but it's worth testing at any rate.
                * I think I should still create a UsedNamespaces object, for code consistency and clarity.
                    * The fullyQualifiedName will just never have namespaces to use, and that's fine.
                * But I'm probably going to have to make a change to the UsedNamespaces class as it is in that case.
            + Empty `uses` element.
                * The damn DOMText is getting in the way.
                * But there's something funky here.  It doesn't seem to be showing up as a problem in the test-usednamespaces file, and I don't know why not.
                ! Oh, because this has nothing to do with UsedNamespaces.
                    * I don't think.
                    * I never tested the existing ClassBuilder stuff empty uses tags.
                    * I think I can fix this by using the getImmediateChildren method instead of looping all child nodes.
            + No `uses` element.
                * This is going to have to involve a change to the UsedNamespaces class, I think.
                * A null input just makes an empty array.  That should do it.
        + Pass to MethodBuilder.
            * Okay, I went away and now I'm coming back and have to remind myself what I'm doing.
                * I made the UsedNamespaces class.
                    * Its only public function (apart from constructor) is fullyQualifiedName.
                    * This is intended to be used only for docblocks.  That's the only place where we'll need a fully qualified name.
                * There will be one UsedNamespace instance per instance of ClassBuilder.
                * Now I need to actually use it in MethodBuilder, in particular the docblock.
                * Okay, but I just remembered something important-- The DocblockBuilder class does not handle it-- It just takes the results as string.
            * MethodBuilder can't have it in constructor.
            + Add the property, getter, and setter.
            + Set from ClassBuilder.
        + Use in MethodBuilder docblock.
            + Input
            + Sidequest: space after comma in argument separations.
            + Return
        + Sidequest: Are there variant inputs?
            * I feel like I might have broken them if there were.
            * I should probably abstract this somehow.
            * I don't think it was working even before this.  Right now it's a backslash, which I doubt it was before.
            * I definitely need to abstract this.
            * But I'm realizing that this might be something I'll need in properties.
            * So, it might be best to actually put it in ElementBuilder?
                * But if so, then I'll want the UsedNamespaces in ElementBuilder, too.
                * Which would more-or-less make sense, since the UsedNamespaces will also be used by the PropertyBuilder.
            * Okay, but I'm actually realizing that that's not going to make as much sense as I realized, because in one case the type is for $input and for another it's $this.
            * I do still think it's better to have usedNamespaces as part of the parent class, though.
            * I was thinking of actually making this a separate function from the class, since I'm going to have to be passing the "$this" or "$input" to it, but I think that's going to make it even more difficult.
                * Oh, actually, since the argument passed to "getAttribute" can itself be different, I won't actually be able to do that, either.
        - Fix huge bug with |
            * If contains multiple types, then namespaces will treat it as one type.
            --Already listed as a later todo item.
        - Sidequest: Fix bug with multiple types in input variables in signature.
            * "bug" isn't actually quite the right word.  Just haven't implemented the feature correctly yet.
            * But this has nothing to do with the used namespaces.
            --Oh, this is already listed as a later todo item.
        + Fix second method in test.
            * It's missing the UsedNamespaces object.
        + Fix `?` in input type.
            * I think I'm going to have to treat it as a special case.
            * Okay, I nearly have this done but I really hate the way it's working.
                * Because it's basically using private variables that are going to switch frequently *every* time fullyQualifiedName is called.  Basically using a variable with the scope of the object but only using it for the scope of the function.
            * Okay, I actually did this wrong, and kinda feel dumb about it.
                * I need to either completely ignore the '?' here or add the '|null'.
                    * I'm leaning towards the former.
                * I already deal with |null *somewhere* else, but I can't remember where, and I don't want to duplicate effort.
                * So, this is just going to extract the "?", and that's it.
        + Deal with '|null'
            * For some reason, this is only dealt with in return value as it is?
            * I'm actually now thinking this probably *would* be best dealt with in the UsedNamespaces class.
        - Empty uses element.
            * Missing works fine, but need to handle empty.
            --No, it's fine.  I had a problem in my test xml.
        + Double-check void return type.
            * If it's not defined, it needs to be "void" in docblock and undefined in sig.
            * Good thing I checked-- Right now it's saying "variant".
                * Crud, and I think it's because of what I just did.
            * Oh, I *think* I just have a problem with how the behavior is defined.
            * Because if it's *defined* as void, it works fine.  If it's not defined, it works fine as variant.
                * And that actually makes sense to me.
            * And that's *exactly* what it already says in the readme.
        + Double-check variant return type.
            * If it's defined as "variant" in docblock, needs to be undefined in sig.
                ! Not, that's not right-- If it's *not defined* it needs to be undefined in sig.
            * Okay, this is working as expected.
        + Pass to PropertyBuilder.
            * Note that this now has the setUsedNamespaces function since it's part of the parent class.
            + Pass to property builder.
            + Use in docblock `var`.
            + Pass to MethodBuilder for getters and setters.
        * I think that's everything.
        + Make sure empty or no use elements still works.
            * Good chance this was already done, but can't be too careful since I haven't looked at this in awhile.
    + Figure out type enforcement for non-primitive, non-used.
        * Should it use backslash?
        * At the moment, it does for docblocks, because that's part of the Fully-Qualified name, and doesn't for signature.
        * What I'm thinking right now is that it shouldn't, and it was stupid to automatically add the backslash to docblocks.
        * If I want the backslash in the output, it needs to be in the input.
        - Remove backslash from being automatically added to usedNamespaces output.
            ! Wait, I'm actually not that sure that I want it that way.
            * I think I was wrong.  To be consistent, I want the backslash in the docblock and not in the type enforcement.
                * Because, presumably, I will *always* have any required uses if it's going to be in the signature, even if it's something like StdClass or DateTime.  That means in the sig, it won't have a backslash, ever.
                * And I always want the fully-qualified namespace in the docblock.  That means in the docblock, it will start with a backslash for any instance of a class.
            --So, not doing this.
        + Test property with StdClass
            + In uses
            + Not in uses
            - With and without backslash.
                --Not necessarty.
+ Fix double-space problem in docblock description..
    * If there's a double-space on a line break, it causes a superflous end-of-line space.
    * I think easiest way to do this would just be to trim the lines.
+ Multiple types for inputs.
    + Docblocks
        * I'm thinking this might need to be handled from the UsedNamespaces class, since types are going to be going through there all the time anyway.
            * That *is* how nullables are handled, after all.
        * But this is also going to be a little strange.  To be as robust as I'd like, I'll want to break apart by exploding it by "|".
            * And the existing "fullyQualifiedName" will need to be moved to another function.
    + Signatures.
        * Just treat as variant if there's a "|" in the type.
        * There's already a "dontEnforceReturnType" variable, but it's kind of stupidly organized.
            * Because it shouldn't be just for return.
+ Multiple types for return.
    * Looks like I already did variant return types in signatures.
    + Docblock
        * Ended up being doing everything for docblocks at once.
+ Multiple types for properties.
    * When done with above, that may actually end up handling this.
        * It did.
+ interfaces
    * i.e., implements
    * This is *using* interfaces, not making them.
    * I'm tempted to skip this since I basically never use interfaces.
        * Even though nobody else will use this, though, I just feel compelled to do it.
    * This is going to be in openClass, I think.
+ If information is small enough, docblock needs to go on one line.
    * And also assuming that there's no more than one attribute.
    * And assuming that that one attribute has no more than one element in `data`.
    * Trying to figure out how to organize this:
        * Function singleLineDoc()
            * Builds full line.
            * Assuming that there's one or fewer attributes and only one element in `data`.
        * Function isSingleLine
            * Returns false if more than one attribute (but no attributes allowed).
            * Returns false if the one attribute, if it exists, has more than one element in `data`.
            * Returns false if singleLineDoc() is too long.
                * Not sure off the top of my head what would constitute too long, but I know there's got to be something for this already since the descriptions are being wrapped correctly.
                    * So, this is in buildDocblockDescArray, which is used in both the attribute descriptions and in the main description.
                    * And it's hardcoded, checking lines longer than 80.
                    * I could make a class constant-- LENGTH_STRICTLY_LESS_THAN.
            * Else return true.
        * Updates to write.
            * If isSingleLine, write singleLineDoc() to file.
            * Else, do what it does now.
+ Forcibly disallow single-line docblocks.
    * By that I don't mean input option, but that I never want method docblocks to be single-line.  I only want that for properties and constants.
    * Also class docblocks should never be single line.
    * But superdocs can be.
    * Strangely enough, while testing the property builder, I found this exact situation.
    + Add option.
    + Add to method docblocks.
    + Add to class docblocks.
+ Public properties
    * And I guess protected, too.
    * And I guess this shouldn't impact getters and setters.  If want to make public without getter or setter, I can just disable the getter and setter just like I already do.
    * I want this to be consistent with public/private/protected methods.  But I also want properties to have the option of not requiring <private> tab.
    * So, this is what I'm thinking-- For *both* methods and properties, if not a child of public/private/protected tag, then default to private.
    * But that's for how I want the XML to work.  For now, I need to actually make properties have visibility.
    + PropertyBuilder updates.
        * Defaulting to private.
        ! Consider abstracting this to a trait, or something.
            * Might actually make an abstract class that extends an abstract class, then make MethodBuilder and PropertyBuilder child classes of that class.
        * So, right now I want to make an abstract class child of ElementBuilder.
            * What do I call it?  It's for both properties and methods.  The point is visibility.
            * MemberBuilder?
            * That said, I actually generally don't like extending an extended class.
            * The alternative is to make a trait.
                * And I think I like this idea.  "VisibilityTrait".
        * I want to basically just take all of the "visibility" stuff from MethodBuilder and basically put it in this.
        * Okay, I've abstracted it to a trait, so now I need to add that trait to PropertyBuilder.
        * Added the trait, so now I need to actually *use* the trait.
        * This should be as simple as just wherever it says "private" replace it with the visibility.
    + MethodBuilder updates.
        + Default needs to be private, not public.
            * Ended up doing this when abstracted to trait.
    + ClassBuilder updates
        * Okay, I'm trying to think through this.
            * And I may end up deleting everything below.
            * I want to end up using recursion in some way, and there's going to be a loop in there.
            * Function(el, ?$vis)
                * For each child element, 
                    * If method element, then create method.  If $vis not null, then set it.
                    * Else take the element name, and run function(subel, element name).
            * Doing the above in an abstract way that applies to both properties and methods may be difficult.  May need to use callback functions, which I don't like doing in PHP.
        * After making witePropertiesOrMethodsLoop, this is *definitely* a "Wow, it worked" moment.
        - Properties.
            > Loop through all child elements of the `properties` element.
            > If child is `property` element, then instantiate method.
            > Else recursively call this loop function, with the visibility set.
        - Methods.
            > Loop through all child elements of the `methods` element.
            > If child is `method` element, then instantiate method.
            > Else recursively call this loop function, with the visibility set.
        * I'd assume that I'm going to abstract some of the code for the two above.
        --Above canceled because it took a pretty different form.
        + Rewrite appendMethods using writePropertiesOrMethodsLoop.
        + Rewrite appendProperties using writePropertiesOrMethodsLoop.
            * ...Oh, crap.  There's also constants.
            * Well... Technically, I can just ignore that part and it should work fine.  I don't have to deal with visibility with constants, and the switch in writePropertiesOrMethodsLoop will ignore all of the constant nodes for the same reason those whitespace text nodes are ignored.
            * I could also make constants a special case in the switch.
                * But I don't like that so much because that means not having writePropertiesOrMethodsLoop agnostic, and it also means putting more logic in there than I'd like.  Since it's recursive already, it should remain as simple as possible.
            * I *really* hate do to it this way, but I think that just having writePropertiesOrMethodsLoop ignore constants will be best.  And keep treating the constants separately.
            * Okay-- New problem.  I very specifically designed $propertiesArr to be used, to write the getters and setters at a later time.
                * And it turns out that "use" is passed by value, not reference.
                * But maybe I can trick it with an "ArrayObject" instead of an array.
                * Okay-- Solved by using ArrayObject instead of an array.
            * I have a new "problem" now.
                * The callables that I'm passing to writePropertiesOrMethodsLoop are so similar that I just found a way to avoid it altogether.
                * In a sense, it would make it less versatile.
                * But I think that overall, it would be good.
                * While *technically*, using these callback functions kinda looks good, the code would be a whole lot clearer without it.
                * On the other hand-- These look really similar because these two classes use the same visibility trait.
                * While writePropertiesOrMethodsLoop is very much designed with visibility in mind, I just kind of don't like the idea of assuming that everything going forward being passed will always use that.
                * Even moreso, I feel like errors could be *much* more difficult to debug.  With my other idea, the code block that instantiates the object wouldn't be the same code block that calls "setVisibility".  I could easily see "why the heck is setVisibility being called here" becoming a problem.
                * But there is still something I can do-- Abstract the inside of this function.
                    * But... Where?
                    * Okay, nevermind, not quite that.
                * Well, I guess I'll call it good for now.
    + Update README.
+ Comments between methods.
    * The "methods" element needs to be able to handle `<comment>` elements, which allows creating new comments between elements.
    * Which should use macros.
    * This is mostly inspired by wanting to keep having the "Helper functions below this line" comment after previous changes.
    * I'm thinking this needs to be part of writePropertiesOrMethodsLoop.
        * Which would actually strengthen the case for putting 'constants' in here, too, because it's a special case.
        * Though, it's still not a *great* case, because there could easily be a use case for comments in the midst of both properties and functions.  There's no use case for putting constants in the midst of methods.
    - InLineCommentBuilder
        > Constructor just takes the FileWriter object, comment text, and the indentation level.
        > write() will just write it out.
        ! Wait-- New idea.
            * To reduce code duplication, this *could* just be an option for DocblockBuilder.
            * Oh, that actually works *really* well, I think.
            * The only things that I'd need to change are the beginning of the returned value of buildDocblockLine, and there would be no open and close to the docblock.
            * This way I wouldn't have to figure out how to abstract the line wrapping stuff that I've already done.
        --Canceled in favor of new idea.
    + inLine option for DocblockBuilder.
        * if setInLineOption(true), then use '//' at beginning of each line instead of ' *'.
        * But then there's also the single-line crap.
            * Oh, that's easy to deal with-- isSingleLine returns false if lineComment is true.
        * I'm also not going to bother making special cases for attributes.
        * Dang-- This is causing more problems than I thought.  I have to give special treatment to initializeDoclock and finalizeDocblock.
            * But I still think it's worth it this way, though.
            * Though, I am wondering if there's a better way.  Maybe skip something in the `write` function.
            * I'd just like to avoid checking if line comment in isSingleLine, initializeDocblock, finalizeDocblock, and buildDocblockLine.
                * Though, buildDocblockLine is probably going to be calling another function that actually checks if line comment, but that's different.
            * So, I've got *four* different places that need to check if it's a line comment.  How can I avoid this?
                * One idea:
                    * Don't pull constants directly.  Create a private variable that's an array with keys 'open_docblock', 'close_docblock', 'line_start'.
                    * By default, those pull from the current constants.
                    * setLineComment will then change those values.
                        * Except now I'm thinking that I may want to change how that works, but I'll get to that in a minute.
                    * If using a line comment, then open_docblock and close_docblock are empty strings, and line_start is '//'.
                    * Now, initializeDocblock, finalizeDocblock, and buildDocblockLine should do *nothing* if their corresponding value is empty string (false).
                * I feel like this idea is better, but not great.  It still requires some magic knowledge that a change to one means a change to another.
                    * Well, not *that* much magic knowledge.
                    * For the time being, I think I'm going to go with it.
                * Okay, but how do I deal with the isSingleLine stuff?
                    * I guess if the opening is empty string (falsey), then "singleLine" is not applicable.
                        * Well, no, I don't like this, either.  I want something more explicit.
            + Update isSingleLine
                * Remove the new 'getLineComment', since it's irrelevant.
            + Remove all lineComment stuff.
                * The variable, the getter, the setter.
            + Create array for 'decorations'.
                * Hopefully I can think of a better name than that.
                    * My thinking is that this is kind of like window decorations in desktop environments.
                * I don't think I'm going to bother with getters and setters.
                    * I take that back-- Since I'm using constants for the arrays anyway, I may as well.
            + Reorganize constants.
                * Going to use constant arrays now.
                + DECORATIONS__DOC_BLOCK
                    * Set as current.
                    * Add value for 'singleLineCompatible', set to true.
                + DECORATIONS__LINE_COMMENT
                    * Set null for opening and closing, '//' for line start.
                    * Set singleLineCompatible to false.
            - Create private function for array
                --Canceling this because I don't know what it means.  Hopefully I'll come back to it when it's needed.
            + Create decoration setting public functions.
                + useDocblockDecorations.
                + useLineCommentDecorations.
            + Call useDocblockDecorations in constructor.
            + Update functions to use the $this->decorations property.
                - Each of these needs to return if the corresponding property is empty string.
                    * Wait-- Is that a good idea?  Maybe it should be null.
                    * Because I can foresee this class possibly being used in the future for heredocs and nowdocs.  Those will have empty strings starting for each line.
                    * Note: Heredocs and nowdocs are also a good reason why it's good to have separate property determining if a decoration is single-line compatible instead of checking if opening is empty string or null.  Those are never single-line compatible.
                    --Canceled in favor of below.
                ! Each of these needs to return if the corresponding property is null.
                + initializeDocblock.
                + finalizeDocblock.
                + buildDocblockLine.
                + singleLineDoc.
            + Back to isSingleLine.
                * If !singleLineCompatible, return false.
    + Handle <comment> elements in ClassBuilder.
        * New case in the switch in writePropertiesOrMethodsLoop.
        * Going to be similar to superdocs, but I may want to abstract it to a separate function that's called from the switch.
        ! Be sure to use getNodeText method.
            * That's what uses the macros.
        + Make function that takes in DOMNode object and writes comments to file.
            * This is where I'll want to use the getNodeText function.
            * And it's going to need to be line comment.
        + Call this function from writePropetiesOrMethodsLoop in the switch, for case 'comment'.
    + Update README.
        + Mention comment where/if appropriate.
            * Reminder that it's going to be both in properties and methods.
        + Mention that macros will apply.
+ Consider refactoring ClassBuilder.
    * It's getting to be pretty large.  I'm not 100% sure it's warranted or what can be done, but I want to at least take a look at it.
    * It's almost 600 lines at this point.
    * I can't really think of anything to abstract at the moment, though.
    * Maybe I'll do this later.  I can't quite think of anything that can be abstracted well.
        * Maybe the methods and properties, since they both use writePropertiesOrMethodsLoop.
- Empty line option in properties and methods.
    * I think.  I think it could be useful.
    * Maybe just <br/>, then put that in the switch in writePropertiesOrMethodsLoop.
    * On the other hand, I think this kinda goes against the whole idea of focusing on the logic instead of the code.
        * The whole point of this project is to be able to use XML to focus on logic instead of code.  This is basically adding some of the same mundanity of writing code into writing the xml.
    --So, no, this isn't a good idea.  If I want to have extra spaces somewhere, I need to find another solution.
+ 'throws" attribute for functions.
    * Will need to use usedNamespaces for this.
    * Delimited by spaces.
+ Well, crud, I just realized that there probably needs to be a document for 'throws', like `@throws InvalidArgumentException   If less than zero.`.
    * In which case I don't want attributes-- I want it to be treated similarly to inputs.
    * So, I'll do this next.
    * Okay-- I originally decided to make this the text of the `throws` element, but I'm realizing now that a more future-proof version of this is to make a child element of `desc`.
        * But I have another idea-- I was already planning to make docs for properties and constants and descs for inputs be child elements *later*.  I think I'll make this `desc` attribute for now, and update this at the same time that I do inputs.
        * So, for the time being, do *not* use node text, because I want it to be updated at the same time.
        * But I may want to up that feature in priority.
> Desc for inputs and throwses needs to be child elements so they can be longer.
    * And use macros.
    * Yes, it's "throwses".
> Doc for property *and* constants need to be allowed to be child elements so they can be longer.
    * And use macros.
! Note: 'doc' is the attribute if it's the docblock description.  'desc' is the attribute if it's the description of a docblock attribute.
> Signature needs to be multiline if too long.
    * The 81 constant for docblock needs to be abstracted somewhere.
        * Probably as a CommonConstants class.
> Pass by reference.
    * Reminder: Don't use & in XML.  It needs to be &amp;, and I probably don't want to do it that way, anyway.
    * My current thinking is `passby="ref"`.  Default value of `passby` would be `"val"`.
> Custom setters and getters.
    * Since the whole point of setters and getters is to make them more versatile for doing other things.
    * I'll need to do use CDATA.  Very similar to methods, but still definitely different.
    * I'm actually thinking now that this should just be a method, with the exact same elements as those in the `methods` tag.
        * I think I can just pass a `getter` and `setter` element to the MethodBuilder class.  To my memory, it never checks that the element passed to it is actually a 
> Property doc attribute needs to optionally be a doc child element.
> nullable properties
    * Basically just means type attribute will start with '?' in input and replaced by <type>|null in docblock.
> Variant return types.
    * If return type of property is variant or contains a '|', then don't enforce a type.
- Namespaced docblock types.
    * If input or return type matches one of the 'use' statements, handle accordingly.
    * i.e., in docblocks it needs to be fully-qualified, but in signatures it shouldn't be.
    --Already did this.
- Added comment for // todo and markasincomplete.
    * Because I want to put //dmz1 in there.
    --For the time being, I'm not doing automatic test files.
        * Retrospective:  I don't quite know what I meant by this, but there's not much reason to put something in addition, since it's just going to be the same as using CDATA.
> Filter
    * I want to be able to pass a filter that matches class names, so only class names are built that match that pattern.
> Delete files
    * Need an option to pass from CLI to delete all files that would otherwise be written.
+ No space before functions.
    * I did this as an easy way to prevent space at end of last function, but it's actually causing other problems.
    * If there are no use statements or variables or what-have-you, if the first thing in a class is a function, then there's an unwanted space.
    * I'm going to have to figure out another way to fix that last space.
> Force overwrite.
    * Basically, delete then write.
> Make traits
    * Can use them up until now, but can't create them.
    * Will actually probably just want to make this basically a class object.  It's almost exactly the same thing.
> Make interfaces.
> PHPUnit tests features.
    * Crap.  I just noticed this.
    * PHPUnit has special docblock attributes, like 'covers' and "expectedException".
    * 'covers' and 'expectedException' will both be examples of values that use namespaces.  But expectedExceptionMessage is an example of something that doesn't.
    * I suppose I'll want to keep this generic.  Have like
        @begin=xml@
            <extra-docblock-attributes>
                <attribute type="covers" namespaced="1">MyClass::MyMethod</attribute>
                <!-- "namespaced" isn't good.  The idea is that it will fill in MyClass, but I don't like it. -->
                <!-- I'm actually now thinking that it might be better not to do that at all, but instead just use macros for MyClass.  Don't handle it in the phlute code, just use a macro. -->
                <attribute type="expectedExceptionMessage">Unexpected item in bagging area.</attribute>
            </extra-docblock-attributes>
        @end=xml@
> Space at the end of last method.
    * This was something that I originally fixed in a stupid way, by putting a space before the function.
    * I'm not sure yet how to fix it, but I probably should.

! This is the point where I would call this project probably effectively done for 1.0.
    * Though at this point I'm not actually versioning.

> Return to macroprocessor.
    * These were put off earlier.
    * Note: I don't know if this will work yet, but an idea that I have is to replace all instances of `\$` with something like [[litdol]] at first, then replace that with a literal dollar sign later.
    > Allow literal double quote in argument.
    > Allow literal dollar sign followed by number in macro.
    > Allow literal {{ in source.
> Allow value as child CDATA element for constants.
    * Mostly to let me define big arrays as constants.
